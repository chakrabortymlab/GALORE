# Whole-Genome Alignment

Whole-genome alignment is one of the most direct ways to identify differences between genomes. Alignment software (ex. MUMmer, Minimap2, Cactus) takes two or more assembled genomes and searches for regions that are homologous (derived from the same ancestral sequence) which allows us to line up corresponding regions of the genomes. Once aligned, missing sequences, duplicated regions, or sequences that appear in a different order or orientation are identified. The result is typically an alignment file storing details about the start and end of alignments or a visualization (dotplot or graph) that clearly shows shared vs. unique regions of sequence. 
Here, we use whole-genome alignment to detect **large-scale structural variation (SVs)** such as **insertions, deletions, duplications, and rearrangements** by comparing our assembled genomes to the ISO1 reference.

## Objectives
1. Align *Drosophila* genome assemblies to the **ISO1 reference genome** using **MUMmer4**.  
2. Visualize alignment using **dot plots**.
2. Parse the alignment to identify structural variants (SVs) with **SVMU**.

---

## Step 1. Generate alignment file with MUMmer
First, we will use the program MUMmer to align our assembled genomes to the ISO1 reference.

### Prepare Input Files

Make sure you have the following files in your project directory:

- The *D. melanogaster* **ISO1 reference genome** (FASTA).  
  Example: `dmel-all-chromosome-r6.52.fasta`

- Your strain’s **de novo genome assembly** (FASTA).  
  Example: `BL662_hifiasm_flye_scaffs.fasta`

---

### Align Genomes with MUMmer

We will use the **`nucmer`** command from MUMmer4 to align the query assembly against the reference genome.

```bash

# Run nucmer to align query assembly to the reference
nucmer -p BL662_vs_ISO1 dmel-all-chromosome-r6.63.fasta BL662_hifiasm_flye_scaffs.fasta
```

**Notes:**
- The `-p` option sets the output prefix. In this case, the results will be stored in `BL662_vs_ISO1.delta`.
- The `.delta` file contains detailed information about all alignments between the reference and the query.

---

## Step 2. Visualizing and interpreting dot plots

In Step 1, we aligned genomes using MUMmer, and the results were stored in a delta file. There are different ways to view this alignment:

- **Linear sequence alignments** are more appropriate for showing small variants such as SNPs and small indels in a small genomic region.

- **Dot plots**, however, are much more effective for identifying large scale mutations (≥100 bp) such as insertions, deletions, inversions, and duplications.

In a dot plot:

- The reference sequence is placed along the x-axis.

- The query sequence is placed along the y-axis.

- A point is added at every position where the two sequences are similar.

When the genomes share long stretches of homology (synteny), these points form a diagonal line. Deviations from this diagonal reveal structural changes.

![Synteny dot plot](../images/synteny.png)

---

### SVs in Dot Plots
For demonstration purposes, we’ll use small mutations to show how they would appear in the sequence vs how they appear in a dotplot. Keep in mind that these examples are simplified. In real dot plots, the sequences are much longer and the patterns we interpret (insertions, deletions, inversions, duplications) typically span hundreds to millions of base pairs.

#### Deletion in the query

- A sequence present in the reference (x-axis) is missing in the query (y-axis).

- Appears as a horizontal shift in the diagonal.

![Deletion dot plot](../images/deletion.png)

#### Insertion in the query

- A sequence is present in the query (y-axis) but absent in the reference.

- Appears as a vertical shift in the diagonal.

![Insertion dot plot](../images/insertion.png)

#### Inversion

- The same sequence is present in both genomes but reversed in the query.

- The diagonal flips direction.

- While inversions may be hard to notice in linear alignments, dot plots make even large inversions immediately visible.

![Inversion in dot plot](../images/inversion.png)

#### Duplication in the query

- A sequence is present in multiple copies in the query.

- Appears as stacked parallel diagonals, each representing an additional copy aligning to the same reference region.

![Duplication in dot plot](../images/duplication.png)

--- 

Dot plots are a powerful way to visualize whole-genome alignments and detect large structural variants (SVs). We'll use a python script included in this repository (dotplot_from_delta.py) that uses the alignment information from MUMmer to generate a dot plot.


## Running the Script

The script takes a `.delta` file as input and produces an HTML dot plot.

```bash
python dotplot_from_delta.py BL2969_vs_ISO1.delta --min_idy 90 --out BL2969_vs_ISO1.dotplot.html
```

### Key options:
- `--min_len` : minimum alignment length to plot (default = 1000 bp).  
- `--min_idy` : minimum percent identity (default = 0).  
- `--ref_contigs` : restrict to specific reference contigs.  
- `--qry_contigs` : restrict to specific query contigs.  
- `--out` : name of the output HTML file.


---

## Viewing the Output
The script generates an interactive HTML file, ex. `BL2969_vs_ISO1.dotplot.html`.  
Open it in your browser to explore the alignments:
- Hover over alignments to see coordinates, lengths, and % identity.

---

# Step 3. Identify Structural Variants with SVMU
Instead of looking through the alignment dot plots for mutations, we can automate the identification of SVs using programs that analyze the alignment file and call variants based on this information.

To extract specific **structural variants (SVs)** from the alignment, we will use **SVMU** (*Structural Variants from MUMmer*). A new version of the program is currently under development by the Chakraborty Lab, but for now we can use the currently available version.
First, make sure you have installed SVMU (see [GitHub](https://github.com/mahulchak/svmu) instructions).  

## Run SVMU
Here, we will define **variables**, short names to serve as stand-ins for a file name or path- in this case our reference, query, and the path to the SVMU executable file. After we have assigned a variable, we can use it later by adding `$` to the name.

```bash
# Define variables
ref=dmel-all-chromosome-r6.63.fasta
query=BL2969_hifiasm_primary_scaffs.fa
svmu=/scratch/user/asamano/dmel/tools/svmu/svmu

# Run SVMU on the delta file
$svmu BL2969_vs_ISO1.delta $ref $query l null BL2969_vs_ISO1
```
- `$svmu`: The variable that serves as a place-holder for the full path to the SVMU executable file.
- `*.delta`: Our delta file produced by MUMmer, in this case for strain BL2969
- `$ref`: The variable for the reference genome
- `$query`: The variable for the query genome
- `l`: Don't report SNPs
- `null`: We're not providing a lastz alignment, just the delta file from MUMmer so we set this to null
- `BL2969_vs_ISO1`: A prefix which will be included in all out SVMU output files



**Output:**

SVMU will generate variant calls describing insertions, deletions, copy number changes, and other SVs.  
*Taken from the SVMU GitHub page

- `sv.prefix.txt` = A tab-delimited file that summarizes structural mutations (indels, CNVs, inversions) in the sample genome with respect to the reference genome.  

- `small.prefix.txt`: A tab-delimited file containing SNPs and small indels that occur within syntenic blocks (or MUMs).

- `cnv_all.prefix.txt`: A tab-delimited file with all the reference genomic regions that are present in higher copy numbers (>1) in the sample genome. Those with "trans" in their names mean either that it is a transposable element or non-TE copies of a gene in different chromosomes.

- `cm.prefix.txt`: A bed file with the reference genomic regions that are syntenic between the two genomes. 

We will mainly focus on the **sv.prefix.txt** file, which contains the following columns:
1. Reference chromosome
2. Start position of SV in reference
3. End coordinates of SV in reference
4. SV type. Any SV type containing 'CNV' denotes a copy number variant, a sequence that is present at higher copy number in the reference (R) or query (Q).
5. Query chromosome
6. Start position of SV in the query
7. End position of SV in the query
8. Arbitrary ID assigned to that SV


---

# Step 4. Intersect Variants Discovered with Genes of Interest

We have indentified genome wide SVs based on our genome alignment, but to in order to determine whether any of the marker genes associated with visible phenotypes in our strains are affected by SVs we need to narrow down our focus to SVs that overlap or are near our genes of interest. Module 3.1 showed how to find the genomic coordinates of the mutated genes in each strain from FlyBase. We can now use command line tools like `awk` or programs specifically designed for working with genomic intervals (BEDtools) to determine whether an SV affects our genes.


## awk Approach
Let's say we are working with strain BL554, which carries an allele of the *Ultrabithorax* gene, Ubx<sup>bx-1</sup>.
From Flybase, you will see than the *Ubx* gene is located at 3R:16,656,623-16,734,426 in the ISO1 reference genome. 
The first three columns of SVMU output correspond to the reference chromosome, start, and end position of each SV. We can use `awk` to filter the output on three conditions:

- The first column (reference chromosome) must be '3R'
- The second column (reference start) must be greater than or equal to the start position of the gene
- The third column (reference end) must be less than or equal to the end position of the gene


```bash
awk '$1 == "3R" && $2 >=16656623 && $3<=16734426 {print}' sv.BL554_scaffs_iso1ref.txt > BL554_ubx_svs.txt
```
- `$1 == "3R"`: Makes sure that the 1st column is 3R
- `&&` : When we add this in between our conditions this means conditions on both sides of should be true
- `$2 >=16656623`: The second column must be greater than or equal to 16656623
- `$3 <=16734426`: The third column must be less than or equal to 16734426
- `> BL554_ubx_svs.txt`: We are directing the output to a file

This should output only SVs where the coordinates overlap our gene. 

Continuing with the *Ubx* example in strain BL554, the output should look like this:

```
3R      16665752        16665759        CNV-Q   3R      17392527        17392534        0000006862      7       2       2
3R      16665759        16665759        INS     3R      17391042        17392527        0000006863      1485    2       2.82088
3R      16704044        16704047        nCNV-Q  3R      17438351        17438354        0000006864      3       2.66667 4.33333
3R      16704047        16704047        INS     3R      17430761        17438351        0000006865      7590    2       11.9627
```
Here, we have 4 mutations identified by SVMU which overlap the *Ubx* gene. The causal mutation could be any of these, or it could be a SNP not included in this output. Still, there are several other considerations:
1. Are any of these mutations unique to the strain (or strains) showing the *Ubx*<sup>bx-1</sup> phenotype? If the only strains bearing this mutation are the ones with the phenotype, this is good support connecting it to the phenotype.
2. What part of the gene is affected by the SV? Mutations can have different effects on a gene depending on the region affected. For example, a mutation in the protein coding sequence is very likely to have an effect on the gene, as it could throw off the open reading frame, introduce a premature stop codon, delete an important protein domain. Mutations affecting non-coding sequences are slightly less likely to affect the function of the gene because they don't affect the protein structure BUT that is not to say it will have no effect. Non-coding elements like introns can harbor enhancers and other regulatory elements that control the expression of the gene (expression level, pattern, etc.). 


## BEDtools Approach
You may recall that a **BED file** is a tab-delimited text which has at least 3 columns: chromosome, start position, end position. The output of SVMU is essentially a BED file and can be used with programs like BEDtools to perform comparisons and overlaps with other interval files.
Use **bedtools intersect** to report variants overlapping your gene.

```bash
bedtools intersect -a BL662_vs_ISO1.svmu -b gene_of_interest.bed -wa -wb > gene_variants.txt
```

### Flags explained
- `-a` : first file (SVMU variants).  
- `-b` : second file (gene BED).  
- `-wa` : write the full SVMU record for any overlap.  
- `-wb` : also write the BED record that overlapped.  

### Output (example)

```
2R   7782500   7784000   DEL   ...   2R   7782796   7785067   cinnabar
```

This shows:
- A **deletion (DEL)** in the SVMU calls overlaps the *cinnabar* gene.

---



## Extend to Multiple Genes

If you have a BED file with many genes recorded from FlyBase:

```bash
bedtools intersect -a BL662_vs_ISO1.svmu -b genes_of_interest.bed -wa -wb > sv_gene_overlaps.txt
```

This will output all structural variants intersecting any gene in the list.

---





# TO DO:
1. Practice identifying different SV types from dot plots and save images for your own reference.
2. Run SVMU on your strains of interest and check the dot plot at mutations called by SVMU to see if they appear as expected.