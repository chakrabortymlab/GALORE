# Whole-Genome Alignment


Whole-genome alignment is one of the most direct ways to identify differences between genomes.  
It allows us to detect **large-scale structural variation (SVs)** such as **insertions, deletions, duplications, and rearrangements** by comparing our assembled genomes to a reference.

## Objectives
1. Align *Drosophila* genome assemblies to the **ISO1 reference genome** using **MUMmer4**.  
2. Parse the alignment to identify structural variants (SVs) with **SVMU**.

---

## Step 1. Prepare Input Files

Make sure you have the following files in your project directory:

- The *D. melanogaster* **ISO1 reference genome** (FASTA).  
  Example: `dmel-all-chromosome-r6.52.fasta`

- Your strainâ€™s **de novo genome assembly** (FASTA).  
  Example: `BL662_hifiasm_flye_scaffs.fasta`

---

## Step 2. Align Genomes with MUMmer

We will use the **`nucmer`** command from MUMmer4 to align the query assembly against the reference genome.

```bash

# Run nucmer to align query assembly to the reference
nucmer -p BL662_vs_ISO1 dmel-all-chromosome-r6.63.fasta BL662_hifiasm_flye_scaffs.fasta
```

**Notes:**
- The `-p` option sets the output prefix. In this case, the results will be stored in `BL662_vs_ISO1.delta`.
- The `.delta` file contains detailed information about all alignments between the reference and the query.

---


## Step 3. Identify Structural Variants with SVMU

To extract specific **structural variants (SVs)** from the alignment, we will use **SVMU** (*Structural Variants from MUMmer*).  

First, make sure you have installed SVMU (see GitHub instructions from the Chakraborty Lab).  
Here, we will define variables, short names to serve as stand-ins for a file name or path - in this case our reference, query, and the path to the SVMU executable file. After we have assigned a variable, we can use it later by adding $ to the name.

```bash
# Define variables
ref=dmel-all-chromosome-r6.63.fasta
query=BL662_hifiasm_flye_scaffs.fasta
svmu=/scratch/user/asamano/dmel/tools/svmu/svmu

# Run SVMU on the delta file
$svmu BL662_vs_ISO1.delta $ref $query l null BL662_vs_ISO1
```

**Output:**
- SVMU will generate variant calls describing insertions, deletions, copy number changes, and other SVs.  
- These results can be further filtered or visualized in IGV or custom scripts.

---


## Step 4: Intersect Genes of Interest with SVMU Variants

Use **bedtools intersect** to report variants overlapping your gene.

```bash
bedtools intersect -a BL662_vs_ISO1.svmu -b gene_of_interest.bed -wa -wb > gene_variants.txt
```

### Flags explained
- `-a` : first file (SVMU variants).  
- `-b` : second file (gene BED).  
- `-wa` : write the full SVMU record for any overlap.  
- `-wb` : also write the BED record that overlapped.  

### Output (example)

```
2R   7782500   7784000   DEL   ...   2R   7782796   7785067   cinnabar
```

This shows:
- A **deletion (DEL)** in the SVMU calls overlaps the *cinnabar* gene.

---



## Step 5: Extend to Multiple Genes

If you have a BED file with many genes recorded from FlyBase:

```bash
bedtools intersect -a BL662_vs_ISO1.svmu -b genes_of_interest.bed -wa -wb > sv_gene_overlaps.txt
```

This will output all structural variants intersecting any gene in the list.

---


This approach provides a powerful way to connect raw assemblies to structural variation, which can then be linked to phenotypes or further validated with read mapping.

