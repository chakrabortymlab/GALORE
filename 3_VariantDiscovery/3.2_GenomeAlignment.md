# Whole-Genome Alignment


Whole-genome alignment is one of the most direct ways to identify differences between genomes. Alignment software (ex. MUMmer, Minimap2, Cactus) takes two or more assembled genomes and searches for regions that are homologous (derived from the same ancestral sequence) which allows us to line up corresponding regions of the genomes. Once aligned, missing sequences, duplicated regions, or sequences that appear in a different order or orientation are identified. The result is typically an alignment file storing details about the start and end of alignments or a visualization (dotplot or graph) that clearly shows shared vs. unique regions of sequence. 
Here, we use whole-genome alignment to detect **large-scale structural variation (SVs)** such as **insertions, deletions, duplications, and rearrangements** by comparing our assembled genomes to the ISO1 reference.

## Objectives
1. Align *Drosophila* genome assemblies to the **ISO1 reference genome** using **MUMmer4**.  
2. Visualize alignment using **dot plots**.
2. Parse the alignment to identify structural variants (SVs) with **SVMU**.

---

## Step 1. Generate alignment file with MUMmer
First, we will use the program MUMmer to align our assembled genomes to the ISO1 reference.

### Prepare Input Files

Make sure you have the following files in your project directory:

- The *D. melanogaster* **ISO1 reference genome** (FASTA).  
  Example: `dmel-all-chromosome-r6.52.fasta`

- Your strain’s **de novo genome assembly** (FASTA).  
  Example: `BL662_hifiasm_flye_scaffs.fasta`

---

### Align Genomes with MUMmer

We will use the **`nucmer`** command from MUMmer4 to align the query assembly against the reference genome.

```bash

# Run nucmer to align query assembly to the reference
nucmer -p BL662_vs_ISO1 dmel-all-chromosome-r6.63.fasta BL662_hifiasm_flye_scaffs.fasta
```

**Notes:**
- The `-p` option sets the output prefix. In this case, the results will be stored in `BL662_vs_ISO1.delta`.
- The `.delta` file contains detailed information about all alignments between the reference and the query.

---

## Step 2. Visualizing and interpreting dot plots

In Step 1, we aligned genomes using MUMmer, and the results were stored in a delta file. There are different ways to view this alignment:

- **Linear sequence alignments** (stacking sequences on top of each other) are useful for showing small variants such as SNPs and small indels.

- **Dot plots**, however, are much more effective for identifying larger mutations (≥100 bp) such as insertions, deletions, inversions, and duplications.

In a dot plot:

- The reference sequence is placed along the x-axis.

- The query sequence is placed along the y-axis.

- A point is added at every position where the two sequences are similar.

When the genomes share long stretches of homology (synteny), these points form a diagonal line. Deviations from this diagonal reveal structural changes.

![Synteny dot plot](../images/synteny.png)

---

### SVs in Dot Plots
For demonstration purposes, we’ll use small mutations to compare linear alignments and dot plots. Keep in mind that these examples are simplified. In real dot plots, the sequences are much longer and the patterns we interpret (insertions, deletions, inversions, duplications) typically span hundreds to millions of base pairs. The examples here are just to illustrate how different mutations appear in each type of alignment.

#### Deletion in the query

- A sequence present in the reference (x-axis) is missing in the query (y-axis).

- Appears as a horizontal shift in the diagonal.

![Deletion dot plot](../images/deletion.png)

#### Insertion in the query

- A sequence is present in the query (y-axis) but absent in the reference.

- Appears as a vertical shift in the diagonal.

![Insertion dot plot](../images/insertion.png)

#### Inversion

- The same sequence is present in both genomes but reversed in the query.

- The diagonal flips direction (from lower left → upper right to upper left → lower right).

- While inversions may be hard to notice in linear alignments, dot plots make even large inversions immediately visible.

![Inversion in dot plot](../images/inversion.png)

#### Duplication in the query

- A sequence is present in multiple copies in the query.

- Appears as stacked parallel diagonals, each representing an additional copy aligning to the same reference region.

![Duplication in dot plot](../images/duplication.png)

--- 

Dot plots are a powerful way to visualize whole-genome alignments and detect large structural variants (SVs). We'll use a python script included in this repository (dotplot_from_delta.py) that uses the alignment information from MUMmer to generate a dot plot.


## Running the Script

The script takes a `.delta` file as input and produces an HTML dot plot.

```bash
python dotplot_from_delta.py BL662_vs_ISO1.delta --min_len 1000 --min_idy 90 --out BL662_vs_ISO1.dotplot.html
```

### Key options:
- `--min_len` : minimum alignment length to plot (default = 1000 bp).  
- `--min_idy` : minimum percent identity (default = 0).  
- `--ref_contigs` : restrict to specific reference contigs.  
- `--qry_contigs` : restrict to specific query contigs.  
- `--out` : name of the output HTML file.

---

## Viewing the Output

The script generates an interactive HTML file, ex. `BL662_vs_ISO1.dotplot.html`.  
Open it in your browser to explore the alignments:
- Hover over alignments to see coordinates, lengths, and % identity.

---

# Step 3. Identify Structural Variants with SVMU
Instead of looking through the alignment dot plots for mutations, we can automate the identification of SVs using programs that analyze the alignment file and call variants based on this information.

To extract specific **structural variants (SVs)** from the alignment, we will use **SVMU** (*Structural Variants from MUMmer*). A new version of the program is currently under development by the Chakraborty Lab, but for now we can use the currently available version.
First, make sure you have installed SVMU (see GitHub instructions).  

## Run SVMU
Here, we will define variables, short names to serve as stand-ins for a file name or path - in this case our reference, query, and the path to the SVMU executable file. After we have assigned a variable, we can use it later by adding `$` to the name.

```bash
# Define variables
ref=dmel-all-chromosome-r6.63.fasta
query=BL662_hifiasm_flye_scaffs.fasta
svmu=/scratch/user/asamano/dmel/tools/svmu/svmu

# Run SVMU on the delta file
$svmu BL662_vs_ISO1.delta $ref $query l null BL662_vs_ISO1
```

**Output:**
- SVMU will generate variant calls describing insertions, deletions, copy number changes, and other SVs.  


---


## Step 4: Intersect Genes of Interest with SVMU Variants

Use **bedtools intersect** to report variants overlapping your gene.

```bash
bedtools intersect -a BL662_vs_ISO1.svmu -b gene_of_interest.bed -wa -wb > gene_variants.txt
```

### Flags explained
- `-a` : first file (SVMU variants).  
- `-b` : second file (gene BED).  
- `-wa` : write the full SVMU record for any overlap.  
- `-wb` : also write the BED record that overlapped.  

### Output (example)

```
2R   7782500   7784000   DEL   ...   2R   7782796   7785067   cinnabar
```

This shows:
- A **deletion (DEL)** in the SVMU calls overlaps the *cinnabar* gene.

---



## Extend to Multiple Genes

If you have a BED file with many genes recorded from FlyBase:

```bash
bedtools intersect -a BL662_vs_ISO1.svmu -b genes_of_interest.bed -wa -wb > sv_gene_overlaps.txt
```

This will output all structural variants intersecting any gene in the list.

---


This approach provides a powerful way to connect raw assemblies to structural variation, which can then be linked to phenotypes or further validated with read mapping.

